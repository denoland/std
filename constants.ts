import IsolateApi from './isolate-api.ts'
export type { IsolateApi }
export const IO_PATH = '.io.json'
import {
  Change,
  CommitObject,
  IsolateApiSchema,
  IsolateReturn,
  MergeRequest,
  Outcome,
  Params,
  PID,
  PierceRequest,
  Request,
  SolidRequest,
  UnsequencedRequest,
} from './api/web-client.types.ts'
import FS from '@/git/fs.ts'
import type DB from '@/db.ts'
import type Executor from '@/exe/exe.ts'

/** Artifact Context, including the db and executor */
export type C = { db: DB; exe: Executor }

export type IsolateFunction =
  | (() => unknown | Promise<unknown>)
  | ((...args: [Params]) => unknown | Promise<unknown>)
  | ((...args: [Params, IsolateApi]) => unknown | Promise<unknown>)

export type IsolateFunctions = {
  [key: string]: IsolateFunction
}
export type IsolateLifecycle = {
  '@@mount': (api: IsolateApi) => Promise<IsolateReturn> | IsolateReturn
  '@@unmount'?: (api: IsolateApi) => Promise<IsolateReturn> | IsolateReturn
}
export type Isolate = {
  api: IsolateApiSchema
  functions: IsolateFunctions
  lifecycles?: IsolateLifecycle
}

export type Poolable = MergeReply | MergeRequest | PierceRequest

export type EffectRequest = {
  target: PID
  /**
   * The hash of the function that was called, to ensure repeatability
   */
  fingerprint: string
  sequence: number
}
export type SolidReply = {
  target: PID
  sequence: number
  outcome: Outcome
}
export type MergeReply = SolidReply & {
  /**
   * Where did this merge reply come from?
   */
  source: PID
  /**
   * The commit that solidified this merge reply, which is used as a merge
   * parent in the recipient branch, so that any changes to the fs can be
   * accessed and so the provenance of the action is included.
   */
  commit: string
}
export type IsolatePromise = {
  outcome?: Outcome
  request: UnsequencedRequest
  resolve?: (value: unknown) => void
  reject?: (error: Error) => void
}
export type Solids = {
  oid: string
  commit: CommitObject
  /** Changed files in this commit.  Empty change signals deletion. */
  changes: { [key: string]: Change }
  exe?: { request: SolidRequest; sequence: number }
  branches: number[]
  poolables: (MergeReply | MergeRequest)[]
  deletes: { pid: PID; commit: string }[]
}
export type Branched = {
  /** The first request in the new branch */
  origin: SolidRequest
  /** The branch PID that needs to be created in /.git/refs */
  pid: PID
  /** The head of the new branch that needs to be created in /.git/refs */
  head: string
}
export type ExeResult = ExeSettled | ExePending
type ExeSettled = {
  settled: {
    reply: MergeReply
    /**
     * The last filesystem that was modified during the execution run.  The FS
     * might have been bumped forwards if accumulations occurred.
     */
    fs: FS
  }
  /** If this is a side effect request, this is the lock held by for it */
  effectsLock?: Deno.KvEntry<string>
}
type ExePending = {
  pending: Pending
  /** If this is a side effect request, this is the lock held by for it */
  effectsLock?: Deno.KvEntry<string>
}
export type Pending = {
  /** The commit that caused the requests to be generated */
  commit: string
  /** The requests that were generated by the latest round of execution */
  requests: UnsequencedRequest[]
  /** The sequence number to accumulate the pending requests against */
  sequence: number
}

export const isMergeReply = (poolable: Poolable): poolable is MergeReply => {
  return 'commit' in poolable && 'outcome' in poolable
}
export const isMergeRequest = (poolable: Request): poolable is MergeRequest => {
  return 'commit' in poolable && 'proctype' in poolable
}
/**
 * Messages that go on the queue are one of three types.  Each one is an
 * operation that will result in a new commit, atomically.  Each operation is
 * able to detect when it is a duplicate task due to duplicate message delivery.
 * Each task will continue to retry until it is successful, as long as its check
 * for duplication reassures it to keep trying.
 */
export type QueueMessage = QueuePool | QueueExe | QueueBranch | QueueHeadSplice
export enum QueueMessageType {
  POOL = 'pool',
  EXECUTION = 'exe',
  BRANCH = 'branch',
  HEAD_SPLICE = 'head-splice',
}
export type QueuePool = {
  type: QueueMessageType.POOL
  poolable: MergeReply | MergeRequest | PierceRequest
}
export type QueueExe = {
  type: QueueMessageType.EXECUTION
  request: SolidRequest
  commit: string
  sequence: number
}
export type QueueBranch = {
  type: QueueMessageType.BRANCH
  parentCommit: string
  parentPid: PID
  sequence: number
}
export type QueueHeadSplice = {
  type: QueueMessageType.HEAD_SPLICE
  ulid: string
  pid: PID
  path?: string
}

export const isQueuePool = (m: QueueMessage): m is QueuePool => {
  return m.type === QueueMessageType.POOL
}
export const isQueueExe = (m: QueueMessage): m is QueueExe => {
  return m.type === QueueMessageType.EXECUTION
}
export const isQueueBranch = (m: QueueMessage): m is QueueBranch => {
  return m.type === QueueMessageType.BRANCH
}
export const isQueueSplice = (m: QueueMessage): m is QueueHeadSplice => {
  return m.type === QueueMessageType.HEAD_SPLICE
}

export * from './api/web-client.types.ts'
