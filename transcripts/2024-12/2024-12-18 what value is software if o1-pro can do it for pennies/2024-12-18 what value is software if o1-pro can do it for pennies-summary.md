0:03 [Tom]: The situation is we've had 01 Pro for 13 days.  
0:09 [Tom]: We've burned between 60 and 100 bucks worth of tokens every day, an unprofitable amount from OpenAI’s perspective.  
0:16 [Scott]: True, and we've been at it nearly around the clock.  
0:22 [Tom]: We’ve made tools to hit its context window limit, which turns out to be 200k tokens.  
1:11 [Tom]: First problem: I can get 01 to make advanced software just by chatting, more advanced than I can manually. This will get more extreme in a few years. The cost of software will approach zero. What should a software engineer do in such a world? As a startup, we should cash in quickly before this advantage disappears.  
2:30 [Tom]: We must decide what to push on, because soon everyone can generate code cheaply, nullifying our advantage.  
3:33 [Tom]: Second problem: Now that code generation is easy, my previous role was coding and yours was inference. Now I can do both. What's the best configuration for our partnership?  
4:44 [Tom]: With 01 Pro, I can handle tasks you did plus coding. What’s most effective for us now?  
5:22 [Tom]: We should think of Dream Catcher Command as an entity. Even though it can’t think yet, soon it might. We should ask it questions from its own perspective. Our capabilities have radically changed.  
6:35 [Tom]: Third problem: The trucking guys can’t survive without software. Now we can make code rapidly. Before, we forced them onto our platform because code was hard to produce. Now code is easy, so maybe they don’t need to run on our platform. They’re ready to pay. We must figure out a deal that doesn’t hurt our principles but helps them and us. Also, we must reassess our roles and whether we need more people.  
9:33 [Tom]: Summarizing:  
- Problem 1: Future of coding and our advantage.  
- Problem 2: Our partnership configuration now that AI can do both coding and inference.  
- Problem 3: The trucking clients need a solution urgently.  
10:14 [Scott]: The skill now is going meta—meta on code and prompting. We can generate a lot quickly, but that can overwhelm us. We need structures (like knowledge trees) to prevent choking on complexity.  
11:19 [Tom]: We produce correct stuff so fast we can’t process it. 
11:26 [Scott]: Trusting it blindly is dangerous. We must manage complexity carefully.  
11:45 [Scott]: We have history and a shared understanding. We’re both going meta, converging in the same conceptual space.  
14:09 [Scott]: We must accelerate our acceleration.  We can do this by going meta on our knowledge structures.
15:02 [Scott]: At the same time, we must deliver the trucking app.  We can do this by using our new code generation capabilities.
14:40 [Tom]: About the trucking guys: we could solve their problem quickly, but we haven’t. We’re stuck defining Dream Catcher perfectly. Maybe just deliver something concrete now.  
15:50 [Tom]: My wife’s input helped clarify options:  
- M&A for revenue stability. Risky if we pick wrong targets or the market changes.  
- Selling software short-term, capitalizing on our current code-generation advantage.  
- Building our blockchain might be cheaper and less risky long-term.  
- Just deliver the trucking app quickly using our new code speed, then decide next steps.  
19:04 [Scott]: Complexity is the key metric. We need Commander to handle complexity.  If we can't handle complexity, we can't do any of those.  Commander relies on our knowledge structures.
19:30 [Tom]: Let’s consider doing the trucking app first, while simultaneously building Commander to manage complexity.  
20:02 [Tom]: Plan: I focus on delivering the trucking app with rapid code generation. You focus on Commander and knowledge structures. After that, we integrate blockchain.  
22:02 [Tom]: We agree: Commander first to handle complexity, then blockchain.  
23:01 [Scott]: Commander’s knowledge structure is priority so we can deal with acceleration.  
24:05 [Tom]: I can do trucking without Commander, but it’s better with it.  
25:02 [Scott]: Commander leads to blockchain. Blockchain depends on good complexity management.  
26:09 [Tom]: Resolve complexity first, then trucking, then blockchain. Defer M&A until we have a stable platform.  
27:04 [Tom]: Our advantage is temporary; we must build tools and capture value quickly.  
28:16 [Scott]: After delivering Commandertrucking and then progressing on blockchain, we re-check M&A or other moves.  
29:04 [Scott]: Record contributions for later attribution.  
30:01 [Scott]: Commander essential for complexity and scaling.  
31:03 [Tom]: Trucking for immediate revenue, blockchain for long-term, Commander for complexity.  
32:02 [Tom]: Final approach: Tom does trucking, Scott does Commander and knowledge structure, then blockchain, M&A later.  
33:07 [Tom]: Switcing topic: 01 API now allows tool calls and structured outputs. Effort parameter affects reasoning cost.  
34:40 [Tom]: Must watch costs. High reasoning effort is expensive.  
35:02 [Scott]: Automate processes so we’re not manually cutting and pasting. Build a platform to handle concurrency and complexity.  
36:09 [Scott]: This platform reduces manual overhead.  
38:00 [Scott]: Solve complexity with foundational tools first.  
39:54 [Scott]: Unify repos into one for consistent management.  
42:05 [Tom]: Track tasks (“stucks”), estimate and measure actual times, improve forecasting.  
44:50 [Tom]: Define data structures for stuck management and knowledge representation.  
46:09 [Scott]: We need one repo, one branching strategy, we QA each other’s merges.  
48:30 [Tom]: A stable internal development process improves quality and speed.  
51:04 [Tom]: Good data structures for stucks enable cohesive Commander and blockchain.  
54:00 [Scott]: Once stable internally, delivering trucking is easy, then moving on to blockchain.  
55:02 [Tom]: With stable pipeline, we deliver trucking quickly for revenue.  
56:22 [Tom]: We have a plan: unify repos, do Commander first, then trucking, then blockchain, then reconsider M&A.  
57:05 [Tom]: Record everything, learn continuously.  

